type
  PNode = ^Node; // Определяем новый тип PNode, который является указателем на тип Node
  Node = record // Определяем новый тип Node, который является записью, состоящей из:
    Elem: Integer; // Поле для хранения целочисленного значения (элемента)
    Next: PNode; // Поле для хранения указателя на следующий узел типа PNode
  end;

var
  newNode, head, tail, pp: PNode; // Объявляем четыре указателя newNode, head, tail, pp типа PNode
  max, min, n: integer; // Объявляем три целочисленные переменные max, min, n

begin
  Write('Введите количество элементов списка: '); // Выводим запрос на ввод количества элементов списка
  Read(n); // Считываем введенное количество элементов в переменную n

  if n <= 0 then // Если количество элементов меньше или равно 0
    writeln('Ненадо так') // Выводим сообщение "Ненадо так"
  else
  begin
    for var i := 1 to n do // Цикл для создания n узлов списка
    begin
      new(newNode); // Выделяем динамическую память для нового узла
      newNode^.elem := random(1, 100); // Задаем новому узлу случайное значение элемента от 1 до 100
      newNode^.next := nil; // Устанавливаем указатель на следующий узел в nil

      if head = nil then // Если список пуст
        head := newNode // Новый узел становится головой списка
      else
      begin
        tail := head; // Инициализируем указатель tail указателем head (начало списка)
        while tail^.next <> nil do // Пока не достигнут конец списка
          tail := tail^.next; // Переходим к следующему узлу списка
        tail^.next := newNode; // Устанавливаем указатель next последнего узла на новый узел
      end;

      writeln(newNode^.elem); // Выводим значение элемента нового узла
    end;

    pp := head; // Инициализируем указатель pp указателем head (начало списка)
    max := pp^.elem; // Инициализируем max значением элемента первого узла
    min := pp^.elem; // Инициализируем min значением элемента первого узла

    while (pp^.next <> nil) do // Пока не достигнут конец списка
    begin
      if (max < pp^.elem) then // Если текущий элемент больше max
        max := pp^.elem; // Обновляем max
      if (min > pp^.elem) then // Если текущий элемент меньше min
        min := pp^.elem; // Обновляем min
      pp := pp^.next; // Переходим к следующему узлу списка
    end;

    Writeln; // Переходим на новую строку
    Writeln('Максимальный элемент: ', max); // Выводим максимальный элемент
    Writeln('Минимальный элемент: ', min); // Выводим минимальный элемент
  end;
end.